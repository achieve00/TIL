# 2025-03-25 TIL

## 1. OS 강의(1~2강)
- **내용 요약**
    - 1강
        - 컴퓨터에서 로그인을 한다는 건 나를 대신하는 무언가를 만든다는 것을 말함 ⇒ “process”
        - GUI 상에서 계정 정보를 입력하여 로그인 프로세스를 실행하여 로그인 → 로그인 프로세스를 통해 Shell 프로세스 실행
        - shell process에서 그 사용자에 해당하는 권한을 부여함
        - 그 Shell에 있는 권한에 따라 시스템에 있는 명령어를 사용하거나 할 수 있음
            - 보통 권한은 상속됨
        - 여기서 해커가 피해자의 시스템상 프로세스에 오작동을 유도해 실행되지 말아야할 코드를 실행시켜 관리자의 권한을 따낼 수 있음
        - 이를 방지하는 기술이 SecureOS이며 kernel에서 실행(OS 수준에서 모니터링)
    - 2강
        - Tread: CPU가 처리하는 실행(연산)의 단위
            - OS의 관리 대상
        - tread는 running과 suspend를 상태 전환을 하며 프로세스를 진행
        - Sleep 함수에서 발생할 때는 작업을 쉬는 것이 아니라 (인수)ms 만큼 스케줄러에서 제외된다는 의미
        - 따라서 호출자 thread가 상태 전환이 발생하며 얼마나 쉬었나 알 수 없으며 이를 통해서 “우연”(Random)이 발생함

- **강의 영상**
    - https://www.youtube.com/watch?si=u2R0sjdxFiMi1S3u&v=ZrNp9Be83qQ&feature=youtu.be
    - https://youtu.be/Js1HSwUurpw?si=5YdJAgoeXiPITrEk


## 코딩 테스트(이코테)
- **진행 파트**: 그리디 알고리즘
- **내용**
    - **그리디 알고리즘**: 탐욕법이라고도 불리며, 매 순간에서 가장 좋은 것을 선택하는 알고리즘
        - 선택 이후에 생길 상황까지는 고려하지 않음
    - 사전에 외우고 있지 않더라도 풀 수 있을 가능성이 가장 높은 문제 유형
    - 다익스트라 알고리즘은 엄밀히 이야기하면 그리디 알고리즘에 속함
        - 이는 암기가 필요
    - 문제에서 ‘가장 큰 순서대로’, ‘가장 작은 순서대로’ 같은 언급이 나오면 그리디 알고리즘을 이용한 문제일 가능성이 높다.
        - 이는 정렬 알고리즘과 짝을 이루어 출제되는 경우가 많음
    - 그리디 알고리즘으로 해법을 찾았을 경우에는 그 해법이 정당한지 검토할 필요가 있음
    - 위의 문제를 그리디 알고리즘으로 해결 가능한 이유
        - 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없음
    - 그리디 알고리즘으로 해결 할 수 있나 확인 → 다른 알고리즘으로 해결할 수 있나 확인
- **예제: 거스름돈**
    - 코드: [링크](https://github.com/achieve00/CodingTest/blob/main/%EC%9D%B4%EC%BD%94%ED%85%8C/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88.py)
    - 로직은 맞지만 코드가 너저분하여, 다시 최적화 진행
- **실전 문제: 큰 수의 법칙**
    - 코드: [링크](https://github.com/achieve00/CodingTest/blob/main/%EC%9D%B4%EC%BD%94%ED%85%8C/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%81%B0%20%EC%88%98%EC%9D%98%20%EB%B2%95%EC%B9%99.py)
- **실전 문제: 숫자 카드 게임**
  - 코드: [링크](https://github.com/achieve00/CodingTest/blob/main/%EC%9D%B4%EC%BD%94%ED%85%8C/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%88%AB%EC%9E%90%20%EC%B9%B4%EB%93%9C%20%EA%B2%8C%EC%9E%84.py)
- **실전 문제: 1이 될 때까지**
    - 코드: [링크](https://github.com/achieve00/CodingTest/blob/main/%EC%9D%B4%EC%BD%94%ED%85%8C/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/1%EC%9D%B4%20%EB%90%A0%20%EB%95%8C%EA%B9%8C%EC%A7%80.py)

## Reflection
- **오늘 배운 것**
    - 로그인 과정에서 프로세스가 어떻게 생성되고 권한이 상속되는지 이해했다.
    - 해커가 프로세스 오작동을 유도해 권한을 획득할 수 있다는 점이 인상적이었고, OS 차원에서 모니터링하는 “SecureOS” 개념이 중요하다는 걸 알았다.  
    - Thread가 CPU의 실행 단위라는 사실, 그리고 Sleep 함수 호출로 인한 상태 전환(스케줄러에서 제외)이 ‘우연’(Random) 요소를 야기한다는 점을 배웠다.
    - 그리디 알고리즘은 “현재 선택이 이후의 최적해를 보장한다”는 점이 핵심이지만, 항상 정당성을 따져봐야 한다는 것을 다시금 상기하게 됐다.  
    - 예제 문제(거스름돈)와 실전 문제(큰 수의 법칙, 1이 될 때까지) 풀이 중, 정렬과 함께 사용하는 경우가 많다는 것도 확인했다.  
    - 앞으로는 문제 풀이 후 “깔끔한 코드 구조”에 더 신경을 써야겠다.
