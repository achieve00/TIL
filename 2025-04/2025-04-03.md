# 2025-04-03 TIL

## 1. 코딩테스트
- 플랫폼: 프로그래머스
- 문제: 연속된 부분 수열의 합
- LV: 2
- 코드: [링크](https://github.com/achieve00/CodingTest/blob/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/LV2/%EC%97%B0%EC%86%8D%EB%90%9C%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4%EC%9D%98%20%ED%95%A9.py)
- 아이디어:
    - 첫번째 풀이
        -모든 가능한 부분 수열 구간의 합을 계산
        - 길이 1부터 len(sequence)까지 순회하며, 각 구간을 슬라이싱하고 np.sum으로 합 계산
        - 처음으로 합이 k인 부분 수열을 만나면 즉시 반환
    - 두번째 풀이
        - 투 포인터 슬라이딩 윈도우 알고리즘 사용
        - start, end 포인터로 구간을 유지하면서 합이 k가 되는 구간 탐색
        - 합이 k일 경우 → 현재 길이가 기존보다 짧으면 갱신
        - 이후에도 계속 탐색, 더 짧은 구간이 나올 수 있으므로 한 번으로 끝내지 않음
- issue: 
    - 첫번째 풀이
        - 시간복잡도: $$O(n^2)$$
        - np.sum도 내부적으로 루프 돌아서 느림
        - 길이가 짧은 구간을 찾긴 하지만, 여러 개가 있을 경우 가장 먼저 찾는 걸 반환 → 가장 짧은 길이를 보장하진 않음
        - 수열이 길어지면 시간 초과 발생
    - 두번째 풀이
        - 테스트 케이스가 "가장 짧은 구간"을 요구하는데, 첫 번째로 발견된 구간을 바로 리턴하는 문제가 있었음